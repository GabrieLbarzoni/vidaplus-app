// Em functions/index.js, adicione esta rota:

// Rota para cancelar/excluir uma consulta
app.delete("/api/appointments/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const appointmentRef = db.collection("appointments").doc(id);
        const doc = await appointmentRef.get();

        if (!doc.exists) {
            return res.status(404).json({ message: "Consulta não encontrada." });
        }

        // NOTA: A verificação de permissão abaixo é um passo de segurança importante.
        // Ela assume que seu middleware de autenticação (que não está no arquivo de contexto, mas deve existir no seu projeto)
        // já validou o token do usuário e adicionou o `profileId` dele ao objeto `req.user`.
        // Se o usuário não for o "dono" da consulta, a exclusão é bloqueada.
        const appointmentData = doc.data();
        if (req.user && appointmentData.patientId !== req.user.profileId) {
             return res.status(403).json({ message: "Você não tem permissão para cancelar esta consulta." });
        }

        await appointmentRef.delete();

        res.status(200).json({ message: "Consulta cancelada com sucesso." });
    } catch (error) {
        console.error("Erro ao cancelar consulta:", error);
        res.status(500).send({ message: "Erro interno ao cancelar a consulta." });
    }
});
    const functions = require("firebase-functions");
    const admin = require("firebase-admin");
    const express = require("express");
    const cors = require("cors");

    // Inicializa o app do Firebase para que as funções possam acessar outros serviços
    admin.initializeApp();

    const app = express();
    // Usa o middleware do CORS para permitir requisições do nosso front-end
    app.use(cors({origin: true}));
    app.use(express.json());

    // Middleware de autenticação
    const authenticate = async (req, res, next) => {
        if (!req.headers.authorization || !req.headers.authorization.startsWith("Bearer ")) {
            return res.status(403).send("Unauthorized: No token provided.");
        }
        const idToken = req.headers.authorization.split("Bearer ")[1];
        try {
            const decodedIdToken = await admin.auth().verifyIdToken(idToken);
            req.user = decodedIdToken; // uid, email, etc.
            next();
        } catch (error) {
            console.error("Error while verifying Firebase ID token:", error);
            res.status(403).send("Unauthorized: Invalid token.");
        }
    };


    // Pega a referência do nosso banco de dados Firestore
    const db = admin.firestore();

    // ======================================================
    // ROTAS DA API COM FIRESTORE
    // ======================================================

    // Rota para verificar o status do perfil do usuário
    app.get("/user/status", authenticate, async (req, res) => {
        try {
            const uid = req.user.uid;
            const patientDoc = await db.collection("patients").where("userId", "==", uid).limit(1).get();
            if (!patientDoc.empty) {
                const profile = patientDoc.docs[0];
                return res.status(200).json({hasProfile: true, role: "patient", profileId: profile.id});
            }
            const professionalDoc = await db.collection("professionals").where("userId", "==", uid).limit(1).get();
            if (!professionalDoc.empty) {
                const profile = professionalDoc.docs[0];
                return res.status(200).json({hasProfile: true, role: "professional", profileId: profile.id});
            }
            return res.status(200).json({hasProfile: false});
        } catch (error) {
            console.error("Erro ao verificar status do usuário:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para buscar todos os pacientes
    // Protegida: Apenas usuários logados podem ver os pacientes
    app.get("/patients", authenticate, async (req, res) => {
        try {
            const snapshot = await db.collection("patients").get();
            const patients = [];
            snapshot.forEach((doc) => {
                patients.push({id: doc.id, ...doc.data()});
            });
            res.status(200).json(patients);
        } catch (error) {
            console.error("Erro ao buscar pacientes:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para CADASTRAR o perfil de um novo paciente (primeiro acesso)
    app.post("/patients", authenticate, async (req, res) => {
        try {
            const {name, cpf, celular, dataNascimento} = req.body;
            const uid = req.user.uid;

            // Verifica se já existe um perfil para este usuário
            const patientDoc = await db.collection("patients").where("userId", "==", uid).get();
            const profDoc = await db.collection("professionals").where("userId", "==", uid).get();
            if (!patientDoc.empty || !profDoc.empty) {
                return res.status(400).json({message: "Usuário já possui um perfil."});
            }

            // Validação simples de CPF duplicado
            const snapshot = await db.collection("patients").where("cpf", "==", cpf).get();
            if (!snapshot.empty) {
                return res.status(400).json({message: "CPF já cadastrado."});
            }
            const newPatientData = {name, cpf, celular, dataNascimento, userId: uid};
            const newPatientRef = await db.collection("patients").add(newPatientData);
            res.status(201).json({id: newPatientRef.id, ...newPatientData});
        } catch (error) {
            console.error("Erro ao cadastrar paciente:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para CADASTRAR o perfil de um novo profissional (primeiro acesso)
    app.post("/professionals", authenticate, async (req, res) => {
        try {
            const {name, cpf, celular, especialidade} = req.body;
            const uid = req.user.uid;

            // Verifica se já existe um perfil para este usuário
            const patientDoc = await db.collection("patients").where("userId", "==", uid).get();
            const profDoc = await db.collection("professionals").where("userId", "==", uid).get();
            if (!patientDoc.empty || !profDoc.empty) {
                return res.status(400).json({message: "Usuário já possui um perfil."});
            }

            const snapshot = await db.collection("professionals").where("cpf", "==", cpf).get();
            if (!snapshot.empty) {
                return res.status(400).json({message: "CPF já cadastrado."});
            }

            const newProfessionalData = {name, cpf, celular, specialty: especialidade, userId: uid};
            const newProfessionalRef = await db.collection("professionals").add(newProfessionalData);
            res.status(201).json({id: newProfessionalRef.id, ...newProfessionalData});
        } catch (error) {
            console.error("Erro ao cadastrar profissional:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para buscar todos os profissionais (agora do Firestore)
    app.get("/professionals", authenticate, async (req, res) => {
        try {
            const snapshot = await db.collection("professionals").get();
            const professionals = snapshot.docs.map((doc) => ({id: doc.id, ...doc.data()}));
            res.status(200).json(professionals);
        } catch (error) {
            console.error("Erro ao buscar profissionais:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para agendar uma nova consulta
    app.post("/appointments", authenticate, async (req, res) => {
        try {
            const {patientId, professionalId, date} = req.body;
            const newAppointment = {
                patientId,
                professionalId, // ID do profissional agora é uma string do Firestore
                date,
            };
            const newAppointmentRef = await db.collection("appointments").add(newAppointment);
            res.status(201).json({id: newAppointmentRef.id, ...newAppointment});
        } catch (error) {
            console.error("Erro ao agendar consulta:", error);
            res.status(500).send(error.message);
        }
    });

    // Rota para buscar todas as consultas (com join de pacientes e profissionais)
    app.get("/appointments", authenticate, async (req, res) => {
        try {
            const uid = req.user.uid;
            let query = db.collection("appointments");

            // Verifica se o usuário logado é um paciente
            const patientDoc = await db.collection("patients").where("userId", "==", uid).limit(1).get();

            if (!patientDoc.empty) {
                // Se for paciente, filtra as consultas pelo ID do perfil do paciente
                const patientProfileId = patientDoc.docs[0].id;
                query = query.where("patientId", "==", patientProfileId);
            }
            // Se não for paciente (ex: profissional, admin), a query busca todas as consultas.

            const appointmentsSnapshot = await query.orderBy("date", "asc").get();
            const appointmentsData = appointmentsSnapshot.docs.map((doc) => ({id: doc.id, ...doc.data()}));

            if (appointmentsData.length === 0) {
                return res.status(200).json([]);
            }

            // Pega todos os IDs de pacientes únicos das consultas
            const patientIds = [...new Set(appointmentsData.map((app) => app.patientId))];
            const professionalIds = [...new Set(appointmentsData.map((app) => app.professionalId))];

            // Busca os dados dos pacientes de uma só vez
            const patientsSnapshot = patientIds.length ? await db.collection("patients").where(admin.firestore.FieldPath.documentId(), "in", patientIds).get() : {docs: []};
            const patientsMap = new Map();
            patientsSnapshot.forEach((doc) => {
                patientsMap.set(doc.id, doc.data());
            });

            // Busca os dados dos profissionais de uma só vez
            const professionalsSnapshot = professionalIds.length ? await db.collection("professionals").where(admin.firestore.FieldPath.documentId(), "in", professionalIds).get() : {docs: []};
            const professionalsMap = new Map();
            professionalsSnapshot.forEach((doc) => {
                professionalsMap.set(doc.id, doc.data());
            });

            // Adiciona os nomes aos dados da consulta
            const populatedAppointments = appointmentsData.map((app) => {
                const patient = patientsMap.get(app.patientId);
                const professional = professionalsMap.get(app.professionalId);
                return {
                    ...app,
                    patientName: patient ? patient.name : "Paciente não encontrado",
                    professionalName: professional ? professional.name : "Profissional não encontrado",
                };
            });

            res.status(200).json(populatedAppointments);
        } catch (error) {
            console.error("Erro ao buscar consultas:", error);
            res.status(500).send(error.message);
        }
    });

    // Expõe o app Express como uma única Cloud Function chamada 'api'
    exports.api = functions.https.onRequest(app);
